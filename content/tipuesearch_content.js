var tipuesearch = {"pages": [{'title': 'About', 'text': 'cd2020-bg1分組網站: https://s40723246.github.io/cd2020-bg1/content/index.html \n group members 吳沛汶Repository: \xa0 40723201 \xa0 | Site: \xa0 40723201 王冠驊Repository: \xa0 40723206 \xa0 | Site: \xa0 40723206 \xa0(小組長) 杜玗宸Repository: \xa0 40723213 \xa0 | Site: \xa0 40723213 林子欽Repository: \xa0 40723216 \xa0 | Site: \xa0 40723216 洪維成Repository: \xa0 40723223 \xa0 | Site: \xa0 40723223 高立倫Repository: \xa0 40723226 \xa0 | Site: \xa0 40723226 陳羽泓Repository: \xa0 40723229 \xa0 | Site: \xa0 40723229 \xa0 (小組長) 陳冠樺Repository: \xa0 40723230 \xa0 | Site: \xa0 40723230 葉承叡Repository: \xa0 40723241 \xa0 | Site: \xa0 40723241 趙子得Repository: \xa0 40723242 \xa0 | Site: \xa0 40723242 \xa0(小組長) 鄭竣元Repository: \xa0 40723246 \xa0 | Site: \xa0 40723246 \xa0 (group leader) \n', 'tags': '', 'url': 'About.html'}, {'title': 'Weeks', 'text': 'week1~5 \n week6~9 \n week10~14 \n week15~18 \n', 'tags': '', 'url': 'Weeks.html'}, {'title': 'week1~5', 'text': '\n 建立cd2020倉儲\xa0\xa0 \n 1.下載 2019Fall可攜套件.7z \xa0 (編譯\xa0 Solvespace 用)，完成後開啟。 2.登入個人github帳號，創建新的倉儲cd2020。 3.進入要存放的 資料夾 4.輸入 git clone \xa0 https://github.com/s40723216/cd2020 \xa0。 5.輸入git submod u le add https://github.com/mdecourse/cmsimde.git 。 6.將up_dir的裡的資料複 製到cd2020 。 7.完成後，python wsgi.py 開始編輯倉儲。 8.編輯完成後， \xa0 git add . \xa0> \xa0 git commit -m "\xa0 " \xa0 > \xa0 git push。\xa0  \n \n 更新python至3.8.2 \n 1.至 pyson官網 >downland> windows ，下載下圖勾選的檔案 \n \n 2.完成後開啟安裝檔，點選Customize installation \n \n 3.將pip取消勾選後按下一步 \n 4.將安裝位置改成Y槽的py382資料夾(自行建立)，其餘不變 \n 5.安裝好後將start_mdecourse進行編譯，將py373皆改為py382 \n \n 6.儲存後並重新啟動，在黑窗輸入指令: python get-pip.py \n 7.進度條跑完後接著輸入: python -m pip install\xa0 flask \n flask-cors 、markdown、 lxml 、bs4、 pelican 、leo \n \n \n 依序輸入並跑完後即完成更新。 \n \n 小組分配工作以及問題討論 \n \n \n \n 第一次直播開會影片: https://www.youtube.com/watch?v=nKNgEypBalo \n \n', 'tags': '', 'url': 'week1~5.html'}, {'title': 'week6~9', 'text': '\n 1.OBS連接，為往後可能線上課程做準備。 \n 2.設定往後影片頭像 \n OBS下載網址: https://obsproject.com/download \n 範例影片: \n \n 四輪車的基本外型設置及模擬 \n ※作業一 \n 根據主題0和主題1的資料來了解完成四輪機器人需要做到那些步驟 \n 以下為vrep環境下的操作 \n 1.首先先製作車身本體以及車子大小 \n \n 調整完後把車身調高比較方便插入插入稍後需加入的輪子和傳動軸 \n 2.加入輪子和傳動軸 \n 須將這兩個物件的y.z軸選轉90度，已安裝至車身 \n \n \n 3.馬達調整功率 \xa0 \n 藉由勾選motor properties以啟動馬達，並可以藉由調整轉動速度和力矩達到所想要馬達轉動之效果，底下的lock motor when target velocity is zero 則可以使馬達速度為零時鎖定住馬達 \n \n 4.檢查碰撞 \xa0 \n 物件的動力學設定也必須要設定好，如下方所示物體的碰撞和物體的動態都必須打開，才能使剛剛設定好的馬達進行對輪胎的帶動 \xa0 \n \xa0 \n 以上操做都沒問題即可成功向前移動。 \n 以下為操作影片: \n \n \n 第一組第二次直播會議 \n \n . 第一組\xa0 第二次會議\xa0\xa0\xa0 \xa0 (WEEK2 ) \xa0 \n \xa0 1.成員簽到等候 \xa0 \n 2.分工作業進度回報及問題討論 \xa0 \n 3.有問題的同學提出問題 \xa0 \n \xa0 成員名單 \xa0 \n 1. 40723201 \xa0 ( 簽 ) \xa0 已建立完成網站 \xa0 \n 2.40723206 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 3.40723213 (簽) \xa0 已建立完成網站 \xa0 \n 4.40723216 (簽) \xa0 已建立完成網站 \xa0 \n 5.40723223 (簽) \xa0 已建立完成網站 \xa0 \n 6.40723226 (簽) \xa0 已建立完成網站 \xa0 \n 7.40723229 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 8.40723230 () \xa0 已建立完成網站 \xa0 \n 9.40723241 (簽) \xa0 已建立完成網站\xa0 \xa0 \n 10.40723242 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 11. 40723246 \xa0 (group leader) (簽) \xa0 \xa0 \n 12.40732319 () \xa0 \n \xa0 分工作業進度回報及問題討論 \xa0 \n \xa0 ※作業一 (4 輪 車) \xa0 \n *根據主題 0 和主題 1 的素材，您能否具體描述機械設計團隊，為了完成作業四輪機器人需要做些 什麼? \xa0 \n \xa0 ※作業二 (設計 協同) \xa0 \n * 根據主題 \xa0 Topic 0 們可以創建英語英語詞彙收集服務嗎？ \xa0 \n *根據主題 \xa0 Topic 1 \xa0 我們可以構建在線工具來促進這些過程嗎？ \xa0 \n \xa0 *Topic 0: \xa0 From Digital to Industrial + Engineering Product Design Collaboration ( 從數字到工業+工程產品設計協作 ) \xa0 \n 設計 資料 : DigitalProductCollaboration.pdf 、 IndustrialAndEngineeringProductDesignCollaboration.pdf \xa0 \n Can we create an \xa0 english-english \xa0 vocabulary collection service? \xa0 \n 相關 網站: https://www.autoitscript.com/forum/files/file/419-dictionary_bigdb/ \xa0 \n *Topic 1 : \xa0 Mechanical Design Process ( 機械設計過程 ) \xa0 \n Login to your gm email account and download \xa0 MechanicalDesignProcess.pdf . \xa0 \n 以上由 40723206 分配工作 \xa0 \n \xa0 下列為分工表格 \n \xa0 1.各組員下載OBS，以往後會議討論用 \xa0 \n \n 作業二必須在 4/23 前完成，並上傳 pdf 檔到個人倉儲的 download 上。 不會做的可以問會的同學或在 gitter 上發問。 \n 請依每個人的作業二pdf檔、網站內容，進行互評。 \n \n', 'tags': '', 'url': 'week6~9.html'}, {'title': 'week10~14', 'text': 'w10開會紀錄: \n 作業三 : 根據對 Topic2 和 Topic3 的閱讀，使用 CoppeliaSim 、 Webots 、 Onshap e 提出一個機電一體化項目。 \n topic2: \n coppeliasim :40723246 \n MSModelingAndTFApproaches.pdf . 207頁:5人 40723216 40723213 40723223 40723241 40723230 \n MechatronicDesignCases.pdf . 46頁:2人 40723229 40723206 \n topic3: \n MechaFutureAndChallenges.pdf . 38頁:1人 40623246 \n MechaEducFutureNeed.pdf . 20頁:1人 40723242 \n google API設置 \n 1.登錄到您的@gm帳戶 2. 啟用Google的API 3. 按設置同意按鈕按鈕 4. 外部用戶類型 5. 進入“憑據”頁面 6. OAuth 2.0客戶端ID 類型的憑據 7.(設置網址) 授權的JavaScript為：https：// localhost：8443 8. 定義URI為：https：// localhost：8443 / login / google / 9. 將oauth_gm.txt保存中 10.開啟leo更改其中得config中的scrum為自己命名的txt檔案名稱，並且修改完成之後按下save和darwROC 11.pip install authomatic 12.開啟https://localhost:8443 13.測試是否可以成功運作 以下為操作影片: \n ubuntu設置 \n 操作步驟: 1.下載 vitualbox 、 ubuntu 等 檔案。 \n 2.開啟vitualbox並匯入ubuntu \n 3.設定網路>選擇nat網路 \n \n 4.檔案>偏好設定>網路>連接埠轉送>將下圖之數據照抄 \n \n 5.啟動UBUNTU後輸入密碼:kmol2020，並進入lxterminal \n 6.依照步驟打開coppeliasim，輸入ls查看內容。 7.cd coppeliasim4_rev4->ls->cd CoppeliaSim_Edu_v4_0_0_Ubuntu18_04->ls->./coppeliaSim.sh。 8.開啟後打開檔案sdc.ttt。 9.開啟啟動器，並開啟下載好的CoppeliaSim四輪車控制器檔案。 10.將檔案中的car_model.py放入編譯器中，並執行。 11.打開CoppeliaSim中的模擬，四輪車開始繞圈即成功。 \n 以下為操作影片: \n \n IPv4 Ubuntu對外連線設定操作 \n 操作影片: 操作步驟: 1.點選檔案->喜好設定->網路->新增一個新的NAT網路。 2.編輯NAT網路->點選連接埠轉送->新增4個新的連接埠轉送埠號。 3.設定主機IP為 127.0.0.1 ；客體IP為 10.0.2.4 ；主機連接埠為 22、19999、17443、18443 ；客體連接埠為 22、19999、7443、8443 。 4.點選設定->網路->設定主機網路為NAT Network。 5.設定完後，點選啟動，接著輸入密碼 kmol2020 。 6.開啟LXTermial，輸入 ifconfig ->輸入 sudo apt install net-tools ->輸入密碼 kmol2020 。 7.cd tmp->ls->輸入ping 127.0.0.1測試->cd cd2020pj1->git pull。 8.接著輸入 sudo vi wsgi.py 編輯內容，按 i 進行編輯。 9.將近端的host改為 10.0.2.4 ，接著按 Esc 並輸入 :wq 存儲。 10.開啟leo，並開啟cd2020pj1.leo，點選Nav搜尋 allowExt 。 11.點選fileuploadfrom，並將第10行新增一個ttt檔，完成後存儲並關閉leo。 12.cd..,接著在tmp下新增oauth_scrum.txt，輸入 sudo vi oauth_scrum.txt 。 13.按 i 編輯，內容先隨便輸入，接著按 Esc 並輸入 :wq 存儲。 14.cd cd2020pj1，並輸入 python3 wsgi.py 啟動。 15.網址為 https:/127.0.0.1:18443/alogin 。 16.帳號及密碼都為 admin ，進入後點選fileuploadform，點選要上傳的ttt檔。 17.點選download list檢查檔案是否上傳完成。 18.完成。 \n IPV6下Ubuntu伺服器連線設定 \n 1. 先設定好網路連線下的host ip \n ( https://github.com/mdecourse/cd2020/blob/master/downloads/w13_ipv6_assignment.txt ) \n \n 2.設定網路的 ipv6 位置設定 \n 3.進入 linux 虛擬主機，依照指令輸入 cd tmp>cd cd2020pj1>git pull >cd docs> cd cmsimde \n 4.輸入 vi wsgi.py \xa0 並且更改 host \n 5.設定好 putty \n 6.按下 save 並且 open 後，在 putty 頁面分別輸入兩次密碼 kmol2020 \n 7.開啟 Xming， 接著輸入 xterm& \n 8.在開啟的視窗中輸入 cd tmp>cd 2020pj1>cd docs>cd cmsimde>python3 wsgi.py \n 用 google 輸入網址 https://[2001:288:6004:17:2020:7221]:17443\xa0 ( 必須要用自己的 ip) \n 9.一開始無法登陸，必須要關閉 proxy ，並且重新整理該頁面就可以了 \n 以下為操作影片: \n \n \n 第四次小組會議 \n 第一組 第四次會議 (WEEK11) 1.成員簽到等候 2.分工作業進度回報及問題討論 3.有問題的同學提出問題 成員名單 1.40723201 (簽) 已建立完成網站 2.40723206 (簽) 已建立完成網站 小組長 3.40723213 (簽) 已建立完成網站 4.40723216 (簽) 已建立完成網站 5. 40723223(簽) 已建立完成網站 6.40723226 (簽) 已建立完成網站 7.40723229 (簽) 已建立完成網站 小組長 8.40723230 () 已建立完成網站 9.40723241 (簽) 已建立完成網站 10.40723242 (簽) 已建立完成網站 小組長 11.40723246 (group leader) (簽) 已建立完成網站 12.40732319 () topic2: coppeliasim:40723246 MSModelingAndTFApproaches.pdf. 207 頁:6 人 40723201 1-30 40723213 31-60 40723216 61-90 40723223 91-120 40723226 121-150 40723246 151-207 MechatronicDesignCases.pdf. 46 頁:2 人 40723229 1-23 40723230 24-46 topic3: MechaFutureAndChallenges.pdf. 38 頁:2 人 40723206 1-19 40523241 20-38 MechaEducFutureNeed.pdf. 20 頁:1 人 40723246 20 \n 參考資料: CMS:http://mde.tw/cd2020pj1/content/CMS.html google 用戶設置影片: \n https://drive.google.com/file/d/1G4MzXUIbNRK7z2XdjtxXzhX51zHHw q85/view?usp=sharing \n \n \n', 'tags': '', 'url': 'week10~14.html'}, {'title': 'week15~18', 'text': 'week15 \n 將Assignment2的分組討論內容進行合併 \n 操作ununtu熟悉再其環境下的操作介面和網路設定 \n week16 \n IPv6連線個人倉儲 \n 1.將ubuntu打開，輸入 cd /etc > cd apt >cd apt.conf.d > sudo vi proxy.conf  \n 密碼:kmol2020 \n 2. 按 i 編輯 成 \xa0 Acquire::http::Proxy:: "[2001:288:6004:17::69]:3128"; 存檔退出 \n 3.在 apt下 輸入 \xa0 sudo apt update\xa0 更新apt ，輸入 \xa0 sudo apt install net-tools ，\xa0 cd /etc > cd netplan > sudo vi 00-installer-config.yaml ，編輯內容如影片 \n 4.在 netplan\xa0下 輸入 ping6 2001:288:6004:17::254 測試 \n 新增ipv4及ipv6埠號,ipv6 的 guestip \xa0 要在 \xa0 netplan下輸入 ifconfig 查詢 ，輸入\xa0 fd17\xa0 那行 \n \n 5.進入 tmp ，輸入 \xa0 git config -- global --add http.proxy [2001:288:6004:17::69]:3128 ，完成後輸入 \xa0 git clone --recurse-submodules 個人倉儲網址 \n 6.進入 cd2020 > cmsimde ，輸入 sudo vi wsgi.py ，將 近端host網址 更改為 個人ipv6的gusetIP \n \n 7. 輸入\xa0 python3 wsgi.py \xa0 開啟近端 \n 8. 將 ipv6的hostip 改為\xa0 \xa0 2001:288:6004:17:2020:2::72個人號碼 \n \n 9.變更網路介面卡設定 \xa0 ipv6位址 為 \xa0 2001:288:6004:17:2020:2::72個人號碼 ， 長度64，閘道2001:288:6004:17::254 ，關閉proxy及防火牆，開起個人近端連線網址為 \xa0 https://[2001:288:6004:17:2020:2::72個人號碼]:19443 \n 即可開始編輯網站。 \n 以下為操作影片: \n \n week17 \n 期末報告影片: \n', 'tags': '', 'url': 'week15~18.html'}, {'title': 'Assignment', 'text': '', 'tags': '', 'url': 'Assignment.html'}, {'title': 'Assignment1', 'text': '', 'tags': '', 'url': 'Assignment1.html'}, {'title': 'Line following BubbleRob tutorial', 'text': '在本教程中，我們旨在擴展BubbleRob的功能，以使他它遵循之前的規則。確保您已經閱讀並理解了第一個BubbleRob教程。本教程由Eric Rohmer提供。 \n 在CoppeliaSim的安裝文件夾中的tutorials / BubbleRob中加載第一個BubbleRob教程的場景。與本教程相關的場景文件位於tutorials / LineFollowingBubbleRob中。 下圖說明了我們將設計的仿真場景： \n \n 我們首先創建3個視覺傳感器中的第一個，並將其附加到bubbleRob對象。選擇[菜單欄->添加->視覺傳感器->正交類型]。通過雙擊場景層次中新創建的視覺傳感器圖標來編輯其屬性，並更改參數以反映以下對話框： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 \n 視覺傳感器必需面向地面，因此選擇它，然後在“方向”對話框中的“方向”選項上，將“ Alpha-Beta-Gamma”項設置為[180; 0; 0]。 \n 我們有幾種可能性可以讀取視覺傳感器。由於我們的視覺傳感器只有一個像素，並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更複雜的情況，我們可以設置視覺回調函數。現在，複製並貼上視覺傳感器兩次，並將其名稱調整為leftSensor，middleSensor和rightSensor。將bubbleRob設置為其關係（即，將其附加到bubbleRob對象）。現在，您的傳感器在場景層次中應如下所示： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n 讓我們正確放置傳感器。為此使用位置對話框，在位置選項卡上，並設置以下絕對坐標： 左傳感器：[0.2; 0.042; 0.018] 中間傳感器：[0.2; 0; 0.018] 右傳感器：[0.2; -0.042; 0.018] 現在讓我們修改環境。我們可以移去BubbleRob前面的幾個圓柱體。接下來，我們將構建機器人將嘗試遵循的路徑。從現在開始切換到頂視圖：通過頁面選擇器工具欄按鈕選擇頁面4。然後點擊[菜單欄->添加->路徑->圓圈類型]。使用鼠標啟用對象移動。您可以通過兩種方式調整路徑的形狀： 選擇路徑（並且只有路徑）後，按住Ctrl並點擊其控制點之一。然後可以將它們拖動到正確的位置。 選擇路徑後，進入路徑編輯模式。在那裡，您可以靈活地調整各個路徑控制點。 \n 一旦對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改），請選擇它，然後在路徑屬性中取消選中“顯示點的方向”，“顯示路徑線”和“顯示路徑上的當前位置”。然後點擊顯示路徑整形對話框。這將打開路徑整形對話框。點擊啟用路徑變更，將類型設置為水平線段，並將縮放因子設置為4.0。最後將顏色調整為黑色。我們必須對路徑進行最後一個重要的調整：當前，路徑的z位置與地板的z位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在openGl行話中被稱為“ z-fighting”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與z戰鬥有關的問題，只需將路徑對象的位置向上移動0.5毫米即可。 \n 最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。打開附加到bubbleRob的子腳本，並將其替換為以下代碼： \n \n \n \n \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n    leftMotor=sim.getObjectHandle("leftMotor")\n    rightMotor=sim.getObjectHandle("rightMotor")\n    noseSensor=sim.getObjectHandle("sensingNose")\n    minMaxSpeed={50*math.pi/180,300*math.pi/180}\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    floorSensorHandles={-1,-1,-1}\n    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")\n    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")\n    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.reate(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor)\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end\n\n    -- read the line detection sensors:\n    sensorReading={false,false,false}\n    for i=1,3,1 do\n        result,data=sim.readVisionSensor(floorSensorHandles[i])\n        if (result>=0) then\n            sensorReading[i]=(data[11]<0.3) -- data[11] is the average of intensity of the image\n        end\n        print(sensorReading[i])\n    end\n\n    -- compute left and right velocities to follow the detected line:\n    rightV=speed\n    leftV=speed\n    if sensorReading[1] then\n        leftV=0.03*speed\n    end\n    if sensorReading[3] then\n        rightV=0.03*speed\n    end\n    if sensorReading[1] and sensorReading[3] then\n        backUntilTime=sim.getSimulationTime()+2\n    end\n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,leftV)\n        sim.setJointTargetVelocity(rightMotor,rightV)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui) end \n \n \n \n \n 您可以輕鬆地調試以下視覺傳感器的生產線：選擇一個，然後在場景視圖中選擇[右鍵->添加->浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵->視圖- ->將視圖與選定的視覺傳感器關聯]。 \n', 'tags': '', 'url': 'Line following BubbleRob tutorial.html'}, {'title': 'portable system', 'text': 'text: \n 將可攜系統下的python 3.7.3系統更新至python 3.8.2 \n 1.先去GOOGLE SEARCH\xa0 PYTHON \xa0 (點這下載) \n 2.下載 Windows x86-64 executable installer \xa0 (點這下載) \n 3.載完點並 不要勾選pip選項，接著按下next選取放置資料夾 \n 4.在隨身系統下新增放置資料夾cd2020，並在cd2020下新建資料夾data，data<py382< wscite432<portablegit \n 5.下載SciTE系統 \xa0 full 64-bit download ，下載完後解壓縮至data下的wscite432 \n 6.在cd2020下建立新的start.bat及stop.bat \n \n 7.至 SciTE系統更改 start.bat及stop.bat \n \n \n 8. 載入MSYS2\xa0 msys2-x86_64-20190524.exe \xa0至data 9. 載入PortableGit\xa0 64-bit Git for Windows Portable \xa0至 portablegit 10 .裝入 pip ，另存新檔到data 11.測試 將python3.8.2版本，將少的模組下載回來 \n \n', 'tags': '', 'url': 'portable system.html'}, {'title': 'random grouping', 'text': 'Random grouping \xa0 \n \xa0 要 進行隨機分組及隨機點名，必須先了解程式裡導入的模組及在模組中所用的 \xa0 語法、迴 圈: request、ast.literal_eval、random、for迴圈 \xa0 \xa0 (1) \xa0 request模組:此模組是為了可以使用 \xa0 Python \xa0 來下載網頁上的資料，是以 \xa0 request模組建立適當的 \xa0 HTTP \xa0 請求，透過 \xa0 HTTP \xa0 請求從網頁伺服器下載 \xa0 指定的資料，分為兩種模式Post、Get。 \xa0 \n \xa0 上述我們將使用 Get 下載回來的資料存入到 a 變數，底下對於 a 變數我們能進行以下操作： \xa0 \n \n url \xa0 : 取得 請求網址 \xa0 \n status_code \xa0 : 伺服器 回應的狀態碼 \xa0 \n text \xa0 : 取得 網頁 HTML 原始碼 \xa0 \n \n 如遇上需要帶上 querystring 參數可以這樣使用： \xa0 參考 文獻: \xa0 https://ithelp.ithome.com.tw/articles/10206215 \xa0 \ufddfHYPERLINK "https://ithelp.ithome.com.tw/articles/10206215" (2) \xa0 ast模組 : \xa0 此 模組是python原始碼到位元組碼的一種中間產物，藉助ast \xa0 模組可以從語法樹的角度分析原始碼結構，其中的語法ast.literal_eval \xa0 是為了能夠安全地評估表達式節點或包含Python文字或容器顯示的字符 \xa0 串。提供的字符串或節點只能由以下Python文字結構組成：字符串、字 \xa0 節、數字、元組、列表、字典、集合、布林值、None。 \xa0 \n Compile函式 \xa0 \n 先簡單瞭解一下compile函式。 \xa0 \n compile( source, filename, mode[, flags[, \xa0 dont_inherit ]])\xa0 \xa0 \n \n source -- \xa0 字串或者AST（Abstract \xa0 Syntax \xa0 Trees）物件。一般可將整個py檔案內容file.read () 傳入 。 \xa0 \n filename -- \xa0 程式碼檔名稱，如果不是從檔案讀取程式碼則傳遞一些可辨認的值 。 \xa0 \n mode -- \xa0 指定編譯程式碼的種類。可以指定為 \xa0 exec, eval, single。 \xa0 \n flags -- \xa0 變數作用域，區域性名稱空間，如果被提供，可以是任何對映物件 。 \xa0 \n \n \n flags和dont_inherit是用來控制編譯原始碼時的標誌 。 \xa0 \n \n \xa0 參考 文獻: https://www.itread01.com/content/1544847254.html \xa0 \xa0 \ufddfHYPERLINK "https://www.itread01.com/content/1544847254.html" (3) \xa0 random模組:此模組用於生成偽隨機數，且有許多種用法，例如:隨機選取 \xa0 choice、隨機選取 \xa0 sample ( 一次選多筆 資料 ) 、 隨機調換順序 \xa0 shuffle (就 \xa0 地調換 順序) 、隨機取得亂數 random (0~1之間的隨機亂數)、隨機取得亂 \xa0 數 uniform \xa0 (可以 指定範圍)。 \xa0 \xa0 參考 文獻: \xa0 https://ithelp.ithome.com.tw/articles/10207483 \xa0 \n (4) \xa0 for迴圈 : \xa0 在處理資料的時候，時常會需要重複執行某些相同的步驟；而迴 \xa0 圈 \xa0 (loop ) 的作用是讓指定的某段敘述在條件符合的情況下一直重覆執行， \xa0 是程式設計中很重要的一種控制結構，且分為兩 類: for、while \xa0 \n \xa0 ○ \xa0 for迴圈基本 語法: for \xa0 變數 \xa0 in \xa0 list、字串、range \xa0 ○ \xa0 while迴圈基本 語法: while \xa0 布林值 \xa0 \xa0 \xa0 \xa0 for迴圈及while迴圈 比較: \xa0 for迴圈比較適用在已知迴圈數的問題，而 \xa0 while迴圈則適用在「無法預知迴圈數」的問題上 。 \xa0 \n 語法 - for \xa0 \n \n A \xa0 、 D \xa0 都省略時， for迴圈 \xa0 跟 \xa0 while迴圈 \xa0 執行起來完全一樣。 \xa0 \n \n for ( [ A.] 一開始先做什麼事 \xa0 ; [B.] 條件式 \xa0 ; [D.] 等C每作完一次，就做什麼事 \xa0 ){\xa0\xa0\xa0 [C.] 當B條件成立時，就重覆做的事 ...} \xa0 \n 通常A、B、D所用到的變數會是一致的。 \xa0 \n \xa0 執行起來流程如下 \xa0 \n 先做 A \xa0 ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ... \xa0 \n ... \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，不成立離開 \xa0 \n \xa0 \n 範例1 - 班級名條 \xa0 \n code \xa0 \n \n # include <iostream> using \xa0 namespace \xa0 std ; int \xa0 main( ){\xa0\xa0\xa0 \xa0 int \xa0 n;\xa0\xa0\xa0 \xa0 int \xa0 i ;\xa0\xa0\xa0 \xa0 cin \xa0 >> n;\xa0\xa0\xa0 \xa0 for ( \xa0 i = 1 \xa0 ; \xa0 i <=n ; \xa0 i =i+ 1 \xa0 )\xa0\xa0\xa0 { \xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 "No." \xa0 << \xa0 i \xa0 << \xa0 endl ;\xa0\xa0\xa0 }\xa0\xa0\xa0 \xa0 return \xa0 0 ;} \xa0 \n for \xa0 vs \xa0 while \xa0 \n \n input \xa0 \n 10 \xa0 \n output \xa0 \n No.1No.2No.3No.4No.5No.6No.7No.8No.9No.10 \xa0 \n \xa0 範例2 - 發射倒數 \xa0 \n \n \n 也可以是做完一次就減少 i \xa0 \n \n # include <iostream> using \xa0 namespace \xa0 std ; int \xa0 main( ){ \xa0\xa0\xa0 \xa0 int \xa0 i ;\xa0\xa0\xa0 \xa0 for ( \xa0 i = 5 \xa0 ; \xa0 i >= 1 \xa0 ; \xa0 i =i- 1 \xa0 )\xa0\xa0\xa0 { \xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 i \xa0 << \xa0 "... " \xa0 << \xa0 endl ;\xa0\xa0\xa0 } \xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 "Go!" \xa0 << \xa0 endl ;\xa0\xa0\xa0 \xa0 return \xa0 0 ;} \xa0 \xa0 參考 文獻: \xa0 https://www.csie.ntu.edu.tw/~b98902112/cpp_and_algo/cpp02/for_loop.html \xa0 \n', 'tags': '', 'url': 'random grouping.html'}, {'title': 'Four wheel car', 'text': 'BubbleRob tutorial :\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0此部分由40723206提供 \n 在此教程中會讓我們設計簡單的BubbleRob機器人並進行一些基礎的模擬操作，而大二上我們其實就有實際的以v-rep操作過這個教程，在這個教程中的說明包括了如何建造模型機器人主體、車輪及後方支撐滑塊，還有如何建造及設置障礙物，以及設定好的距離傳感器後使其去感測並避開我們所設置的障礙物，而最重要的要點是如何去設計指令讓傳動器依照我們所想要的方式去做動，且當距離感測器偵測到障礙物時才能使機器人迅速閃避障礙物，另外還有視覺辨識器，使機器人在移動時，讓我們能夠觀測到機器人行徑方向之路況。 \n \n translation Simulation ~ PDF \n \n \n \n translation\xa0 Simulation dialog ~ PDF \n \n \xa0 \n 在本教程中，我們旨在擴展BubbleRob的功能，以使他/她遵循地面上的規則。確保您已經閱讀並理解了第一個BubbleRob教程。本教程由Eric Rohmer提供。 \n 在CoppeliaSim的安裝文件夾中的tutorials / BubbleRob中加載第一個BubbleRob教程的場景。與本教程相關的場景文件位於tutorials / LineFollowingBubbleRob中。 下圖說明了我們將設計的仿真場景： \n \n 我們首先創建3個視覺傳感器中的第一個，並將其附加到bubbleRob對象。選擇[菜單欄->添加->視覺傳感器->正交類型]。通過雙擊場景層次中新創建的視覺傳感器圖標來編輯其屬性，並更改參數以反映以下對話框： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 \n 視覺傳感器必需面向地面，因此選擇它，然後在“方向”對話框中的“方向”選項上，將“ Alpha-Beta-Gamma”項設置為[180; 0; 0]。 \n 我們有幾種可能性可以讀取視覺傳感器。由於我們的視覺傳感器只有一個像素，並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更複雜的情況，我們可以設置視覺回調函數。現在，複製並貼上視覺傳感器兩次，並將其名稱調整為leftSensor，middleSensor和rightSensor。將bubbleRob設置為其關係（即，將其附加到bubbleRob對象）。現在，您的傳感器在場景層次中應如下所示： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n 讓我們正確放置傳感器。為此使用位置對話框，在位置選項卡上，並設置以下絕對坐標： 左傳感器：[0.2; 0.042; 0.018] 中間傳感器：[0.2; 0; 0.018] 右傳感器：[0.2; -0.042; 0.018] 現在讓我們修改環境。我們可以移去BubbleRob前面的幾個圓柱體。接下來，我們將構建機器人將嘗試遵循的路徑。從現在開始切換到頂視圖：通過頁面選擇器工具欄按鈕選擇頁面4。然後點擊[菜單欄->添加->路徑->圓圈類型]。使用鼠標啟用對象移動。您可以通過兩種方式調整路徑的形狀： 選擇路徑（並且只有路徑）後，按住Ctrl並點擊其控制點之一。然後可以將它們拖動到正確的位置。 選擇路徑後，進入路徑編輯模式。在那裡，您可以靈活地調整各個路徑控制點。 \n 一旦對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改），請選擇它，然後在路徑屬性中取消選中“顯示點的方向”，“顯示路徑線”和“顯示路徑上的當前位置”。然後點擊顯示路徑整形對話框。這將打開路徑整形對話框。點擊啟用路徑變更，將類型設置為水平線段，並將縮放因子設置為4.0。最後將顏色調整為黑色。我們必須對路徑進行最後一個重要的調整：當前，路徑的z位置與地板的z位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在openGl行話中被稱為“ z-fighting”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與z戰鬥有關的問題，只需將路徑對象的位置向上移動0.5毫米即可。 \n 最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。打開附加到bubbleRob的子腳本，並將其替換為以下代碼： \n \n \n \n \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n    leftMotor=sim.getObjectHandle("leftMotor")\n    rightMotor=sim.getObjectHandle("rightMotor")\n    noseSensor=sim.getObjectHandle("sensingNose")\n    minMaxSpeed={50*math.pi/180,300*math.pi/180}\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    floorSensorHandles={-1,-1,-1}\n    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")\n    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")\n    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.reate(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor)\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end\n\n    -- read the line detection sensors:\n    sensorReading={false,false,false}\n    for i=1,3,1 do\n        result,data=sim.readVisionSensor(floorSensorHandles[i])\n        if (result>=0) then\n            sensorReading[i]=(data[11]<0.3) -- data[11] is the average of intensity of the image\n        end\n        print(sensorReading[i])\n    end\n\n    -- compute left and right velocities to follow the detected line:\n    rightV=speed\n    leftV=speed\n    if sensorReading[1] then\n        leftV=0.03*speed\n    end\n    if sensorReading[3] then\n        rightV=0.03*speed\n    end\n    if sensorReading[1] and sensorReading[3] then\n        backUntilTime=sim.getSimulationTime()+2\n    end\n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,leftV)\n        sim.setJointTargetVelocity(rightMotor,rightV)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui) end \n \n \n \n \n 您可以輕鬆地調試以下視覺傳感器的生產線：選擇一個，然後在場景視圖中選擇[右鍵->添加->浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵->視圖- ->將視圖與選定的視覺傳感器關聯]。 \n CoppeliaSim \n 外部控制器教程 在CoppeliaSim中，有幾種方法可以控制機器人或仿真： 最方便的方法是編寫一個子腳本來處理給定機器人或模型的行為。這是最方便的方法，因為子腳本直接附加到場景對象，它們將與相關的場景對像一起復制，它們不需要使用外部工具進行任何編譯，它們可以在線程或非線程模式下運行，它們可以通過自定義Lua函數或Lua擴展庫進行擴展。使用子腳本的另一個主要優點是：與本節中提到的後3種方法（即使用常規API）一樣，沒有通信延遲，並且子腳本是應用程序主線程的一部分（固有的同步操作）。 \n \xa0\xa0\xa0 \xa0 可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使用回調機制，自定義 Lua 函數註冊，當然還可以訪問外部函數庫。插件通常與子腳本結合使用。使用插件的主要優勢還在於，與本節中提到的後 3 種方法（即使用常規 API ）一樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。 \n \xa0\xa0 \xa0 控制機器人或模擬的第三種方法是編寫依賴於遠程 API 的外部客戶端應用程序。如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。遠程 API 有兩個版本：基於 B0 的遠程 API 和舊版遠程 API 。 \n \xa0\xa0\xa0 \xa0 控制機器人或仿真的第五種方法是通過 ROS 節點。 \xa0 ROS 與遠程 API 相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程 API 非常輕巧且快速，但它僅允許與 CoppeliaSim 通信。另一方面， ROS 允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。 \n \xa0\xa0\xa0\xa0 \xa0 控制機器人或模擬的第六種方法是通過 BlueZero （ BØ ）節點。與 ROS 類似， BlueZero 是使多個分佈式進程相互通信的一種便捷方法。 \n \xa0\xa0\xa0\xa0 \xa0 控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與 CoppeliaSim 插件或 CoppeliaSim 腳本進行通信。 \n', 'tags': '', 'url': 'Four wheel car.html'}, {'title': 'Assignment2', 'text': '', 'tags': '', 'url': 'Assignment2.html'}, {'title': 'Assignment3', 'text': '', 'tags': '', 'url': 'Assignment3.html'}, {'title': 'MSModelingAndTFApproaches60~90', 'text': '3.3結論\xa0  \xa0\xa0\xa0 \n 在本章中，介紹了動力學系統的數學建模。 並提出了使用物理定律生成模型的技術。並且需要實驗數據來建立所需的模型。 \n \xa03.4 問題 \n 1. 在這個問題上，我們要求為直流電動機套件建立數學模型不忽略 L 。我們要求建立： （一）傳遞函數 （二）狀態空間描述 \n 2. 建立兩輪機器人的數學模型 \n 3. 建立懸浮系統的數學模型 \n 4. 考慮一個具有傳遞函數的動力學系統。 寫 Matlab 程序，該程序生成一個數據序列（ u （ k ）， y （ k ））。 使用這個數據，在 Matlab 中編寫程序以識別系統並建立數學模型。 比較兩個模型並得出結論。 \n 5. 在狀態空間描述中考慮動力系統。 編寫 Matlab 程序圖生成適當的數據以使用狀態空間標識系統描述方法。 使用這些數據編寫一個 Matlab 程序來建立一個狀態空間描述，並將其與原始描述進行比較。 \n 4.1 導言 \n 現在的單片機功能比較強大，價格也比較實惠。所以大部分的人會選則它。 \n \xa0 \n 4 4. \n 基於轉移函數分析的機電一體化系統。在開 / 關機的情況下，它用於安全和控制的目的。一般情況下不需要花時間就能計算出脈衝發生器的作用。而對於連續時間的情況，微控制器會重新在每個取樣期接收數據 。 \n 在實際使用微控制器控制實際過程時，有以下結構可以採用。 \n 透過輸出通過 A/D 轉換為數字值。轉換器的輸出是通過 A/D 轉換為數字值。在這種情況下，參考是以數字形式送入。 \n 這種結構用以下方式說明 \n 圖 4.1 和 4.2 。 \n \xa0 \n 在圖  4.2  的結構中，我們的採樣信號具有以下特徵 \n 有以下優點。 \n 1. 易於調製 \n 2. 易於編碼 \n 3. 易傳輸、易再生並有積極意義。 \n \xa0 \n 4.2. 取樣過程 \n 在本章的其餘部分，我們將介紹可用於分析的工具。 \n 這種類型的系統。主要是針對一個給定的實際系統。 \n 1. 如何確定採樣週期 \n 2. 如何將連續時間模型轉換為離散時間模型，使用所選的 \n 抽樣期 \n 3. 如何確定這類系統的性能，如穩定性、穩定性、穩定性等。 \n 過衝、沉澱時間等。 \n 4. 如何利用根 - 焦點和 Bode-plot 技術進行離散時間的案例分析。 \n 連續時間和離散時間之間的關係建立。 \n 主要是：兩個域（ s 域和 S 域）的兩極之間的關係已經建立。 \n 第 3 節介紹了傳遞函數的概念和極點的概念。 \n 在第 4 節中，對給定輸入的時間響應進行了開發，並給出了一個給定輸入的時間響應和 \n 第 5 節介紹了計算它的方法。第 5 節介紹了穩定性問題和系統誤差。根定位和博德圖技術的發展再在第 6 和 7 節中具體介紹了這些技術。這些技術被用於分析和設計。 \n \xa04.2 取樣過程 \n 採樣期的選擇採用香農定理。這香農定理的聲明由以下結果給出。 \n 4.2.1  \n 定理 4.2.1  信號 y(t) 不含頻率成分大於 fh 是由一組間隔為單一的 y(t) 取樣集唯一地重構出來適當的 \n 採樣頻率的選擇應滿足： \n \xa0 採樣器的作用是將連續時間信號轉換為等效的連續時間信號。 \n 脈衝序列，而 ZOH 阻斷了從採樣器接收到的值，從而使讀取這些數據的微控制器通過模擬 / 數字轉換器。 \n 採樣過程如圖 4.3 所示 \n \n 反向 Z 變換包括找到與 f(k) 相關的表達式。 sponds to a given function F(z).  是一個非常有用的方法是找到反轉函數的函數 F(z) 的擴展為部分分數， \n 其逆變換為可以在表中找到。這種方法的思路是，首先寫出了 expres- \n z-1 的函數，然後執行擴展為部分分數 \n 如同通常對連續時間的情況下所做的那樣。這種技術可以從以下幾個方面來說明 \n 以下為例：範例 4.2.7 讓我們考慮以下函數 F(z) \n \n 並確定 f （ k ）的表達式。 \n \xa0 採樣系統的傳遞函數的概念可以類似地定義為已經為連續時間。 \n 為了澄清這一點，讓我們參考圖 4.10 ，其中上游採樣器是真實的，而下游採樣器是虛構的。 \n 我們假定在同一採樣期同步的理想值。採樣期間，我們假設為理想值，並在同一採樣期同步。 \n 第二個採樣器被引入，目的是定義 Y(z) ，因此，定義 \n  適當的脈衝傳遞函數。根據圖 4.10 ，我們可以得到 : \n \xa0 \n  因為輸出是由虛構的採樣器採樣，所以我們可以有 \n \n \n', 'tags': '', 'url': 'MSModelingAndTFApproaches60~90.html'}, {'title': 'final report', 'text': '\n', 'tags': '', 'url': 'final report.html'}]};