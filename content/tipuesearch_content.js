var tipuesearch = {"pages": [{'title': 'Weeks', 'text': 'week1~5 \n week6~9 \n week10~14 \n week15~18 \n', 'tags': '', 'url': 'Weeks.html'}, {'title': 'week1~5', 'text': '\n 建立cd2020倉儲\xa0\xa0 \n 1.下載 2019Fall可攜套件.7z \xa0 (編譯\xa0 Solvespace 用)，完成後開啟。 2.登入個人github帳號，創建新的倉儲cd2020。 3.進入要存放的 資料夾 4.輸入 git clone \xa0 https://github.com/s40723216/cd2020 \xa0。 5.輸入git submod u le add https://github.com/mdecourse/cmsimde.git 。 6.將up_dir的裡的資料複 製到cd2020 。 7.完成後，python wsgi.py 開始編輯倉儲。 8.編輯完成後， \xa0 git add . \xa0> \xa0 git commit -m "\xa0 " \xa0 > \xa0 git push。\xa0  \n \xa0 \n 更新python至3.8.2 \n 1.至 pyson官網 >downland> windows ，下載下圖勾選的檔案 \n \n 2.完成後開啟安裝檔，點選Customize installation \n \n 3.將pip取消勾選後按下一步 \n 4.將安裝位置改成Y槽的py382資料夾(自行建立)，其餘不變 \n 5.安裝好後將start_mdecourse進行編譯，將py373皆改為py382 \n \n 6.儲存後並重新啟動，在黑窗輸入指令: python get-pip.py \n 7.進度條跑完後接著輸入: python -m pip install\xa0 flask \n flask-cors 、markdown、 lxml 、bs4、 pelican 、leo \n \n \n 依序輸入並跑完後即完成更新。 \n \n 小組分配工作以及問題討論 \n \n \n \n 第一次直播開會影片: https://www.youtube.com/watch?v=nKNgEypBalo \n', 'tags': '', 'url': 'week1~5.html'}, {'title': 'Assignment1', 'text': '', 'tags': '', 'url': 'Assignment1.html'}, {'title': 'Line following BubbleRob tutorial', 'text': '在本教程中，我們旨在擴展BubbleRob的功能，以使他它遵循之前的規則。確保您已經閱讀並理解了第一個BubbleRob教程。本教程由Eric Rohmer提供。 \n 在CoppeliaSim的安裝文件夾中的tutorials / BubbleRob中加載第一個BubbleRob教程的場景。與本教程相關的場景文件位於tutorials / LineFollowingBubbleRob中。 下圖說明了我們將設計的仿真場景： \n \n 我們首先創建3個視覺傳感器中的第一個，並將其附加到bubbleRob對象。選擇[菜單欄->添加->視覺傳感器->正交類型]。通過雙擊場景層次中新創建的視覺傳感器圖標來編輯其屬性，並更改參數以反映以下對話框： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 \n 視覺傳感器必需面向地面，因此選擇它，然後在“方向”對話框中的“方向”選項上，將“ Alpha-Beta-Gamma”項設置為[180; 0; 0]。 \n 我們有幾種可能性可以讀取視覺傳感器。由於我們的視覺傳感器只有一個像素，並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更複雜的情況，我們可以設置視覺回調函數。現在，複製並貼上視覺傳感器兩次，並將其名稱調整為leftSensor，middleSensor和rightSensor。將bubbleRob設置為其關係（即，將其附加到bubbleRob對象）。現在，您的傳感器在場景層次中應如下所示： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n 讓我們正確放置傳感器。為此使用位置對話框，在位置選項卡上，並設置以下絕對坐標： 左傳感器：[0.2; 0.042; 0.018] 中間傳感器：[0.2; 0; 0.018] 右傳感器：[0.2; -0.042; 0.018] 現在讓我們修改環境。我們可以移去BubbleRob前面的幾個圓柱體。接下來，我們將構建機器人將嘗試遵循的路徑。從現在開始切換到頂視圖：通過頁面選擇器工具欄按鈕選擇頁面4。然後點擊[菜單欄->添加->路徑->圓圈類型]。使用鼠標啟用對象移動。您可以通過兩種方式調整路徑的形狀： 選擇路徑（並且只有路徑）後，按住Ctrl並點擊其控制點之一。然後可以將它們拖動到正確的位置。 選擇路徑後，進入路徑編輯模式。在那裡，您可以靈活地調整各個路徑控制點。 \n 一旦對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改），請選擇它，然後在路徑屬性中取消選中“顯示點的方向”，“顯示路徑線”和“顯示路徑上的當前位置”。然後點擊顯示路徑整形對話框。這將打開路徑整形對話框。點擊啟用路徑變更，將類型設置為水平線段，並將縮放因子設置為4.0。最後將顏色調整為黑色。我們必須對路徑進行最後一個重要的調整：當前，路徑的z位置與地板的z位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在openGl行話中被稱為“ z-fighting”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與z戰鬥有關的問題，只需將路徑對象的位置向上移動0.5毫米即可。 \n 最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。打開附加到bubbleRob的子腳本，並將其替換為以下代碼： \n \n \n \n \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n    leftMotor=sim.getObjectHandle("leftMotor")\n    rightMotor=sim.getObjectHandle("rightMotor")\n    noseSensor=sim.getObjectHandle("sensingNose")\n    minMaxSpeed={50*math.pi/180,300*math.pi/180}\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    floorSensorHandles={-1,-1,-1}\n    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")\n    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")\n    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.reate(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor)\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end\n\n    -- read the line detection sensors:\n    sensorReading={false,false,false}\n    for i=1,3,1 do\n        result,data=sim.readVisionSensor(floorSensorHandles[i])\n        if (result>=0) then\n            sensorReading[i]=(data[11]<0.3) -- data[11] is the average of intensity of the image\n        end\n        print(sensorReading[i])\n    end\n\n    -- compute left and right velocities to follow the detected line:\n    rightV=speed\n    leftV=speed\n    if sensorReading[1] then\n        leftV=0.03*speed\n    end\n    if sensorReading[3] then\n        rightV=0.03*speed\n    end\n    if sensorReading[1] and sensorReading[3] then\n        backUntilTime=sim.getSimulationTime()+2\n    end\n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,leftV)\n        sim.setJointTargetVelocity(rightMotor,rightV)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui) end \n \n \n \n \n 您可以輕鬆地調試以下視覺傳感器的生產線：選擇一個，然後在場景視圖中選擇[右鍵->添加->浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵->視圖- ->將視圖與選定的視覺傳感器關聯]。', 'tags': '', 'url': 'Line following BubbleRob tutorial.html'}, {'title': 'About', 'text': '\n 此內容管理系統以\xa0 https://github.com/mdecourse/cmsimde \xa0作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.', 'tags': '', 'url': 'Develop.html'}]};